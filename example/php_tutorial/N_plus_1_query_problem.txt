	N+1 Query Problem
	
Проблема N+1 запроса (англ. N+1 Query Problem) возникает, когда приложение совершает один SQL-запрос 
для получения некоторых данных, а затем ещё N запросов для получения связанных данных

Чаще всего о проблеме N+1 запроса говорят в контексте ORM-библиотек
	* ORM-библиотеки представляют строки таблиц базы данных в виде объектов, выполняя 
	объектно-реляционное сопоставление (англ. Object-Relational Mapping, сокращённо ORM)
	* Проблема N+1 запроса в ORM-библиотеках возникает при попытке обращения к связанным 
	объектам в случае связи «один-ко-многим»

На данный момент мы не стаем погружаться в тематику ORM, и взглянем на проблему N+1 запроса на ином примере.

	Чтение недавних публикаций
	
Задача:
	* Получить из таблицы post N последних публикаций, в том числе получить параметры N фотографий из 
	таблицы image — по одной фотографии для каждой из выбранных публикаций.

Для получения N последних публикаций подойдёт функция getRecentPostsFromDatabase, которую мы уже рассматривали ранее:

	/**
	 * Извлекает из БД список недавних постов
	 *
	 * @param PDO $connection
	 * @param int $limit
	 * @return array{
	 *      id:int,
	 *      description:string,
	 *      image_id:string,
	 *      author_name:string,
	 *      created_at:string
	 *  }[]
	 */
	function getRecentPostsFromDatabase(PDO $connection, int $limit): array
	{
		// NOTE: запрос сортирует по ID поста, т.к. автоинкрементный ID монотонно возрастает в хронологическом порядке.
		$query = <<<SQL
			SELECT
				id,
				image_id,
				description,
				author_name,
				created_at
			FROM post
			ORDER BY id DESC
			LIMIT $limit
			SQL;

		return $connection->query($query)->fetchAll(PDO::FETCH_ASSOC);
	}

Дальше возникает потребность получить фотографии к каждому из постов.

	Вариант №1 — N запросов
	
В  цикле для каждой публикации вызовем функцию findImageInDatabase(), которая обращается к базе данных для получения одной фотографии.

	Управляющий код

Управляющий код в обработчике (контроллере) HTTP-запроса:

	$connection = connectDatabase();

	// Получаем список постов
	$posts = getRecentPostsFromDatabase($connection, PAGE_SIZE);

	foreach ($posts as $post)
	{
		$imageData = findImageInDatabase($connection, $post['image_id']);
		$imageUrlPath = $imageData
			? getUploadUrlPath($imageData['path'])
			: '';
		// [... рендеринг поста]
	}

	Функция чтения из базы данных

Реализация функции findImageInDatabase():

	/**
	 * Извлекает из БД параметры изображения с указанным ID.
	 * Возвращает null, если параметры изображения не найдены
	 *
	 * @param PDO $connection
	 * @param int $id
	 * @return null|array{
	 *     path:string,
	 *     width:int,
	 *     height:int,
	 *     mime_type:string
	 * }
	 */
	function findImageInDatabase(PDO $connection, int $id): ?array
	{
		$query = <<<SQL
			SELECT
				id,
				path,
				width,
				height,
				mime_type
			FROM image
			WHERE id = $id
			SQL;

		$statement = $connection->query($query);
		$row = $statement->fetch(PDO::FETCH_ASSOC);

		return $row ?: null;
	}

	Недостатки такого решения
	
Отправка и обработка каждого SQL-запроса клиент-серверной СУБД требует времени.

Ниже показаны этапы этого процесса:
	* SQL-запрос сериализуется и отправляется пакетами по протоколу TCP 
	(поверх которого построен протокол MySQL)
		- MySQL принимает TCP пакеты и ожидает завершения передачи данных
	* Парсер SQL в составе MySQL выполняет синтаксический разбор запроса
		- SQL-запрос трансформируется в дерево разбора (англ. Parse Tree)
	* Оптимизатор в составе MySQL строит план выполнения
	* Хранилище InnoDB в MySQL читает данные из таблицы image (т.е. из леса B+-деревьев)
	* Таблица результатов сериализуется и отправляется пакетами по протоколу TCP
		- Расширения PDO и pdo_mysql принимают и десериализуют данные

Теперь посмотрим на это в масштабе:
	* Сколько затрат будет, если нужно выбрать 50 или 100 публикаций?
	* Сколько затрат будет, если для каждой публикации нужно не только выбрать 
	фотографию, но и совершить 10 других вспомогательных запросов?

В реальных Web-приложениях проблема N+1 запроса легко может снизить скорость отдачи 
HTML-страницы с приемлемых 0.5-0.9 секунды до десятков секунд.

	Вариант №2 — один SQL-запрос и словарь
	
Алгоритм получения фотографий:
	* Из списка публикаций извлекаем список ID фотографий
	* Одним SQL-запросом получаем данные фотографий по списку ID
	* Формируем словарь array<int,array>, который отображает ID изображения 
	на его данные в ассоциативном массиве
	* В  цикле для каждой публикации получаем параметры фотографии из словаря и выполняем рендеринг

	Управляющий код
	
Управляющий код в обработчике (контроллере) HTTP-запроса:

	$connection = connectDatabase();
	$posts = getRecentPostsFromDatabase($connection, PAGE_SIZE);

	// 1. Из списка публикаций извлекаем список ID фотографий
	$imageIds = array_column($posts, 'image_id');

	// 2. Одним SQL-запросом получаем данные фотографий по списку ID
	// 3. Формируем словарь array<int,array>, который отображает
	//  ID изображения на его данные в ассоциативном массиве
	$imageByIdMap = getImageToIdMapFromDatabase($connection, $imageIds);

	// 4. В  цикле для каждой публикации получаем
	//  параметры фотографии из словаря и выполняем рендеринг
	foreach ($posts as $postData)
	{
		$imageData = $imageByIdMap[$postData['image_id']] ?? null;
		$imageUrlPath = $imageData ? getUploadUrlPath($imageData['path']) : '';
		// [... рендеринг поста]
	}

	Функция чтения из базы данных
	
В реализации функции getImageToIdMapFromDatabase() есть несколько примечательных вещей:
	* SQL-запрос будет содержать условие вида WHERE IN (?, ?, ..., ?)
		- Здесь мы используем подготовленный запрос (prepared statement) 
		с заполнителями параметров (parameter placeholder)
	* Мы должны обработать ситуацию, когда функции передан пустой аргумент $ids (список ID)
		- В SQL выражение IN () синтаксически некорректно — список в операторе IN не может быть пустым
	* Для генерации списка заполнителей параметров мы используем функцию 
	str_repeat (https://www.php.net/manual/ru/function.str-repeat.php)
		- Выражение: str_repeat('?, ', count($ids) - 1) . '?';
		- Выражение с str_repeat, кстати, тоже не сможет работать с пустым списком $ids
		- Вместо str_repeat можно применить функцию array_fill, которая формирует массив 
		путём копирования заданного значения
		- Выражение: implode(', ', array_fill(0, count($ids), '?'))
	* Для создания словаря используем комбинацию функций array_combine и array_column
		- Выражение: array_combine(array_column($results, 'id'), $results);
		- Функция array_column работает с многомерными массивами, извлекая из каждого 
		вложенного массива одно значение по ключу 
		- Функция array_combine создаёт ассоциативный массив из двух массивов 
		равного размера: первый массив используется для ключей, второй — для значений

Реализация :

	/**
	 * @param PDO $connection
	 * @param int[] $ids - список ID изображений
	 * @return array<int,array> - словарь, отображающий ID изображения на массив с параметрами изображения
	 */
	function getImageToIdMapFromDatabase(PDO $connection, array $ids): array
	{
		if (!$ids)
		{
			// Обрабатываем пустой список параметров
			return [];
		}

		$placeholders = str_repeat('?, ', count($ids) - 1) . '?';
		$query = <<<SQL
			SELECT
				id,
				path,
				width,
				height,
				mime_type
			FROM image
			WHERE id IN ($placeholders)
			SQL;


		$statement = $connection->prepare($query);
		$statement->execute($ids);
		$results = $statement->fetchAll(PDO::FETCH_ASSOC);

		// Из массива создаём словарь, ключом в котором будет ID изображения
		return array_combine(
			array_column($results, 'id'),
			$results
		);
	}

Результат

Второй вариант реализации использует только два SQL-запроса для получения ленты свежих постов:
	* SQL-запрос для получения списка недавних публикаций из таблицы post
	* SQL-запрос для получения списка фотографий по id из таблицы image

Такое решение прекрасно масштабируется — то есть работает с той же скоростью даже при 
увеличении размера выборки свежих постов.

	Вариант №3 — соединения таблиц
	
Та же самая задача легко решается за счёт небольшого усложнения SQL-запроса:
	* Выбираем данные о свежих постах
	* В SQL-запросе соединяем таблицы post и image, чтобы выбрать и публикации, и фотографии
	
Так будет выглядеть SQL-запрос:

	SELECT
		p.id,
		p.description,
		p.author_name,
		p.created_at,
		i.path AS image_path,
		i.width AS image_width,
		i.height AS image_height,
		i.mime_type AS image_mime_type
	FROM post p
	  INNER JOIN image i ON p.image_id = i.id
	ORDER BY p.id DESC
	LIMIT $limit
	
Это решение имеет свою цену:
	* Усложняется как SQL-запрос, так и обработка его результатов в приложении
	* Усложнённый SQL-запрос становится одноразовым
		- показанную ранее функцию getImageToIdMapFromDatabase мы могли 
		переиспользовать многократно с разными целями
		- SQL-запрос с соединениями решает конкретную задачу и переиспользованию не подлежит

Такая цена вполне приемлема для решаемой задачи, но может оказаться намного более 
существенной для реальных задач с большим числом таблиц.

	Выбор оптимального решения
	
В реальных проектах по мере роста сложности запросов в некотором бизнес-сценарии 
рано или поздно потребуется выбрать:
	* Использовать крайне сложный SQL-запрос с соединениями, подзапросами, агрегацией и т.д. 
	для получения данных на конкретной странице
	* Или использовать более простые SQL-запросы, оперируя списками и словарями для достижения 
	хорошей производительности
	* Или проигнорировать проблему N+1 запроса, получая существенную деградацию производительности 
	по мере роста базы данных и усложнения самого приложения

Все три решения могут использоваться в тех или иных ситуациях. 
Разработчик должен сам сделать выбор, принимая во внимание:
	* Предполагаемый минимальный, средний и максимальный объём данных, выгружаемых в этом бизнес-сценарии
	* Перспективы развития приложения и базы данных в ближайшие годы

Следует также трезво оценивать свою способность к написанию надёжно работающией оптимизированной 
версии кода (без дефектов, вызванных усложнением логики).

	Подытожим

	* Проблема N+1 запроса (англ. N+1 Query Problem) возникает, когда приложение совершает один SQL-запрос 
	для получения некоторых данных, а затем ещё N запросов для получения связанных данных
		- Чаще всего о проблеме N+1 запроса говорят в контексте ORM-библиотек
		- Однако даже без ORM эта проблема может проявить себя в полной мере
	* В реальных Web-приложениях проблема N+1 запроса легко может снизить скорость отдачи HTML-страницы 
	с приемлемых 0.5-0.9 секунды до десятков секунд
	* Программисту следует замечать проблемы N+1 запроса и принимать взвешенное решение
		- Для решения проблемы можно написать специализированный SQL-запрос, получающий все данные для 
		некоторого бизнес-сценария за счёт возможностей SQL (соединения, подзапросы, агрегация и т.д.)
		- Иногда полезен иной вариант решения — более простые SQL-запросы и работа со списками или 
		словарями на стороне приложения
		- Проблему N+1 запроса в конкретном бизнес-сценарии можно проигнорировать

























