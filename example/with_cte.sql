/*
Операция присваивания
В реляционной алгебре существует операция присваивания (←), которая используется в двух целях.

Цель 1 — упрощение выражений реляционной алгебры
Операцию присваивания можно использовать для упрощения сложных выражений путём создания новых переменных
Пример: T ← A⋈θB
Читается так: присваиваем отношению T результат тета-соединения отношений A и B по предикату θ
Этой же цели в SQL служит ключевое слово WITH, которое мы обсудим сегодня.

Цель 2 — определение операций, изменяющих данные
Кроме того, операция присваивания позволяет выразить операции вставки / обновления / удаления 
(т.е. INSERT / UPDATE / DELETE в терминах SQL):
Операция вставки: A ← A ⋃ Q
Читается так: присваиваем отношению A результат объединения A и Q
Здесь Q — это множество вставляемых кортежей
Операция удаления: A ← A \ Q
Читается так: присваиваем отношению A разность A и B
Здесь Q — множество кортежей, соответствующих предикату (т.е. условию) удаления
Определение операции обновления мы пропустим для краткости.
*/

/*
Common Table Expressions
Common Table Expressions появились в стандарте SQL:1999
Обычно их называют кратко — CTE
Русский перевод — «обобщённые табличные выражения» — используется редко
CTE — это один или несколько вспомогательных SQL-запросов, называнных собственными именами 
и используемых в остальном запросе. Объявленный в запросе CTE существует только во время выполнения этого запроса.
*/

-- Секция WITH
/*
WITH
  cte_1 AS (SELECT ...),
  cte_2 AS (SELECT ...),
  ...
SELECT ... FROM cte1
  INNER JOIN cte2 ON ...
WHERE ...

Секция WITH может распологаться не только перед SELECT, 
но также перед UPDATE и DELETE либо внутри INSERT...SELECT:
-- CTE в запросе UPDATE
WITH cte_1 AS (SELECT ...)
UPDATE ...
SET ...
WHERE ...
;
-- CTE в запросе DELETE
WITH cte_1 AS (SELECT ...)
DELETE ...
WHERE ...
;
-- CTE в запросе INSERT...SELECT
INSERT ...
WITH cte_1 AS (SELECT ...)
SELECT ...
;
*/

/*
Отличия CTE от подзапроса
По сути каждый CTE — это именованный результат вспомогательного SQL-запроса. 
Это похоже на именованный подзапрос.
Однако CTE имеют преимущества:
- CTE может быть объявлен один раз и использован несколько раз в запросе
- CTE может ссылаться на ранее объявленные CTE, позволяя выполнить серию 
преобразованний данных до основного запроса
- CTE объявляется до основного запроса, что в некоторых случаях намного легче читается
Эти преимущества позволяют использовать CTE для упрощения сложных SQL-запросов, 
что востребовано в аналитических системах.
*/

/*
Пример
Ранее мы рассматривали задачу:
Выбрать все аэропорты в городах с несколькими аэропортами
Один из вариантов решения использовал подзапрос в FROM:
*/
SELECT
  a.airport_code AS code,
  a.airport_name ->> '$.ru' AS name,
  a.city ->> '$.ru' AS city
FROM (
  SELECT
    city
  FROM airports_data
  GROUP BY city
  HAVING COUNT(*) > 1
) tmp
  INNER JOIN airports_data a ON tmp.city = a.city
;
-- С помощью WITH подзапрос можно превратить в CTE:
WITH mutli_airport_cities AS (
  SELECT
    city
  FROM airports_data
  GROUP BY city
  HAVING COUNT(*) > 1
)
SELECT
  a.airport_code AS code,
  a.airport_name ->> '$.ru' AS name,
  a.city ->> '$.ru' AS city
FROM mutli_airport_cities c
  INNER JOIN airports_data a ON c.city = a.city
;
/*
Анализируем план запроса
Извлечём план запроса с помощью EXPLAIN ANALYZE и очистим его от статистики запроса
-> Filter: (a.city = c.city)
  -> Inner hash join (<hash>(a.city)=<hash>(c.city))
    -> Table scan on a
    -> Hash
      -> Table scan on c
        -> Materialize CTE mutli_airport_cities
          -> Filter: (count(0) > 1)
            -> Table scan on <temporary>
              -> Aggregate using temporary table
                -> Table scan on airports_data
- Обратите внимание на строку: Materialize CTE mutli_airport_cities
	- Это строка сообщает, что MySQL сохраняет результат запроса, соответствующего CTE, 
во временную таблицу, чтобы потом использовать в основном запросе
- Кроме того, материализованный CTE затем хешируется для соединения с таблицей 
airports_data с помощью алгоритма Hash Join
*/

/*
Алгоритмы обработки CTE в MySQL
MySQL при обработке CTE может использовать две стратегии:
- Слияние (merge) SQL-запроса из CTE с основным SQL-запросом
	- Следует учитывать, что слияние происходит не на уровне исходного кода на 
	языке SQL, а на уровне деревьев ParseTree
	- ParseTree — это специализированная структура данных типа «дерево», 
	представляющее результаты синтаксического разбора кода на языке SQL
- Материализация результатов SQL-запроса из CTE во временную таблицу
	- Именно эту стратегию мы наблюдали ранее в плане запроса в строке 
    Materialize CTE mutli_airport_cities
Обычно MySQL старается использовать стратегию слияния (merge), поскольку 
результат слияния CTE с основным SQL-запросом можно оптимизировать дальше.
Стратегия материализации CTE используется как резервная.
*/

/*
Подытожим
- Операция присваивания в реляционной алгебре может использоваться для сохранения 
результата нескольких операций в новой переменной
	- Пример: T ← A⋈θB
- В SQL есть CTE (Common Table Expressions), соответствующие операции 
присваивания новой переменной в реляционной алгебре
- CTE — это именованный вспомогательный запрос, описанный в секции WITH ...
	- WITH ... может содержать несколько объявлений CTE, 
    при этом последующие CTE могут ссылаться на предыдущие
	- WITH ... можно использовать в запросах SELECT, UPDATE, DELETE и INSERT...SELECT
- В сравнении с подзапросами, CTE могут улучшить читаемость и сопровождаемость сложных SQL-запросов
- При планировании запроса с CTE для MySQL доступны две стратегии
	- Слияние (merge) SQL-запроса из CTE с основным SQL-запросом
	- Материализация результатов SQL-запроса из CTE во временную таблицу
*/

















