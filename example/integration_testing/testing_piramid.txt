	Уровень 1. Модульные тесты

Модульные тесты (англ. unit tests) состоят из быстро выполняемых тестовых сценариев, работающих с отдельными 
модулями (англ. unit) программы в полной изоляции от внепроцессных зависимостей и от других тестовых сценариев

Разберём это определение подробнее.

Модуль (англ. unit) — это небольшая единица кода, которая обеспечивает некоторую функциональность. 
Обычно модулем называют функцию, файл с функциями или класс; в некоторых случаях модулем называют группу 
взаимосвязанных классов, решающих одну задачу.

Изоляция тестовых сценариев означает, что:
	* Тестируемый модуль и сами модульные тесты не используют внешних (внепроцессных) зависимостей
		- Это обеспечивает высокую скорость выполнения модульных тестов
	* Каждый тестовый сценарий (test case) изолирован от других сценариев
		- Изоляция избавляет от ситуаций, когда один падающий тест вызывает падение ещё нескольких тестов
		- Изоляция позволяет запускать набор тестов в любом порядке, или запускать только определённые тесты

Если в приложении используется фреймворк (например, Symfony), то модульные тесты скорее всего не будут его 
использовать — по тем же причинам.

	Внепроцессные зависимости
	
Внепроцессные зависимости (англ. out-of-process dependencides) — это любые внешние процессы и сервисы, 
необходимые приложению для работы в тех или иных бизнес-сценариях.

Внепроцессные зависимости бывают:
	* управляемыми, если тестируемое приложение единолично контролирует их работу
	* неуправляемыми, если они существуют и развиваются независимо от тестируемого приложения

Модульные тесты не используют никакие внешние (внепроцессные) зависимости. Исключением может быть только 
файловая система, и только если работа с ней не нарушает изоляцию тестов друг от друга.

	Уровень 2. Интеграционные тесты

Интеграционные тесты (англ. integration tests) состоят из тестовых сценариев, каждый из которых проверяет 
один или несколько взаимосвязанных модулей программы с использованием управляемых внепроцессных зависимостей

Таким образом, интеграционные тесты от модульных отличают две детали:
	* Интеграционные тестовые сценарии могут проверять группу взаимосвязанных программых модулей, включая код 
		взаимодействия между ними
	* Интеграционные тесты могут проверять код, использующий базу данных, файловое хранилище и другие 
		управляемые внепроцессные зависимости
		- Сами тесты тоже могут использовать базу данных, файловое хранилище и другие неуправляемые зависимости

В интеграционных тестах обращения к неуправляемым внепроцессным зависимостям (например, запросы к API внешних 
сервисов) должны быть отключены либо заменены на тестовых дублёров (англ. test doubles).

	Подтипы интеграционных тестов

Интеграционные тесты делят на два подтипа:
	* Компонентные тесты проверяют код путём вызова публичных функций и публичных методов классов модулей
	* Функциональные тесты проверяют код с помощью внешнего API — например, путём отправки HTTP-запросов 
		либо путём эмуляции такой отправки

	Уровень 3. End-to-end тесты
	
Сквозные тесты (англ. end-to-end tests, или E2E) состоят из тестовых сценариев, каждый из которых проверяет 
полный сценарий использования приложения, развёрнутого в реальном окружении

Таким образом, сквозные тесты от интеграционных отличают три детали:
	* Сквозной тест проверяет продукт целиком
		- Для Web-приложений это означает, что тестовые сценарии используют бэкенд путём 
			взаимодействия с фронтендом приложения
	* Сквозной тест проверяет полный сценарий использования тем же путём, как это делают 
		QA при ручном тестировании продукта
		- Для Web-приложений это означает, что тестовые сценарии могут выполняться в 
			фоновом браузере (англ. headless browser)
	* Сквозные тесты могут и должны проверять код, использующий любые внепроцессные зависимости
		- Если сквозной тест проверяет покупку на сайте с онлайн-платежом по карте, он должен совершать 
			реальную покупку, что вызовет взаимодействие с платёжной системой и денежную транзакцию 
			(вероятно это будет покупка за 1 рубль)

На самом деле сквозные тесты иногда делают допущения: например, вместо реальной покупки на сайте может 
проверяться только переход на страницу платёжной системы. Каждое такое допущение снижает стоимость сквозных 
тестов, но также снижает их пользу.

	Проверка Web-приложений в браузере

Для сквозных тестов используются специализированные фреймворки, которые запускают полноценный Web-браузер 
в фоновом режиме (это называется headless browser)
	* Наиболее известный фреймворк — Selenium
	* Selenium умеет запускать различные браузеры (Chrome, Firefox, Edge и не только) в фоновом режиме, 
		управляя ими через так называемые «драйверы»

Дщкументация: https://www.selenium.dev/documentation/overview/details/

	Кто пишет сквозные тесты?

Обычно происходит так:
	* Модульные тесты пишет команда разработки — то есть те же программисты, что написали тестируемый код
	* Интеграционные тесты также пишет команда разработки
	* Сквозные тесты пишет команда QA (Quality Assurance)

Сквозные тесты иногда называют приёмочными тестами (англ. acceptance tests), потому что команда QA может 
использовать их для приёмки новых фич продукта.

	Чёрный ящик и белый ящик

Команда QA, в отличие от программистов, не знает внутреннего устройства написанного кода, поэтому:
	* Сквозные тесты, которые пишут QA, работают по принципу «чёрного ящика»
		- QA в сквозных тестах проверяют внешне наблюдаемое поведение программы 
			и её соответствие спецификации
		- По важным вопросам QA уточняют логику работы у команды разработчиков
	* Модульные и интеграционные тесты, которые пишут разработчики, работают по принципу «белого ящика»
		- Разработчик знает внутреннее устройство программы и строит тесты с учётом этого

	Соотношение уровней

Можно встретить подобные убеждения:
	* Наибольший объём тестов должен быть на нижних уровнях

Иногда встречаются более конкретные соотношения:
	* Модульные тесты должны составлять 80%, интеграционные и сквозные тесты — оставшиеся 20% 

В реальных проектах разные уровни приносят различную пользу, и нет никакой заданной пропорции между уровнями.

В каждом проекте следует отдельно решать, какие уровни приносят наибольшую пользу и к какому соотношению 
числа тестов на уровнях следует стремиться.

	Testing Trophy («Кубок Тестирования»)

Идею разных пропорций уровней в разных проектах подчёркивает концепция Testing Trophy, введённая в 2018 году 
Kent C. Dodds (автором React Testing Library):
	* Здесь в основании «кубка тестирования» находится статический анализ. Его иногда выделяют как способ 
		тестирования без запуска кода — это называется статическим тестированием (а обычные автотесты 
		называют динамическим тестированием).

	Testing Icecream (перевёрнутая пирамида)

Существует также концепция перевёрнутой пирамиды тестирования. Эта концепция описывает ситуацию, когда 
автоматизированных тестов в проекте мало и при этом очень много ручного тестирования:
	* Эта схема называется также Testing Icecream за сходство с рожком мороженного.

На практике существенный объём ручного тестирования может и не быть проблемой. Настоящая проблема возникает, 
если нужные проекту уровни пирамиды тестирования отсутствуют или сделаны плохо.

	Первоисточники

Автоматизированное тестирование — это сфера, ориентированная на практику и конкретный опыт. Поэтому взгляды 
разных людей могут кардинально различаться, а статьи могут противоречить друг другу (как следствие разной 
интерпретации личного опыта).

Если в свободное время вы захотите больше узнать о пирамиде тестирования, можете обратиться к первоисточникам:
	* Статья The Forgotten Layer of the Test Automation Pyramid — автор Mike Cohn
		(https://www.mountaingoatsoftware.com/blog/the-forgotten-layer-of-the-test-automation-pyramid) 
		- «Забытым» уровнем в этой статье названы «Service Tests» (тесты сервиса), которые эквивалентны 
			функциональным интеграционным тестам в нашей версии пирамиды тестирования
	* Статья The Practical Test Pyramid — автор МMartin Fowler
		(https://martinfowler.com/articles/practical-test-pyramid.html)
		- Эта статья очень большая и сложная
	* Блог Enterprise Craftsmanship — автор Владимир Хориков
		(https://enterprisecraftsmanship.com/posts)
		- Владимир Хориков также является автором книги «Принципы unit-тестирования», 
			которую в Сети называют лучшей книгой в данной области
