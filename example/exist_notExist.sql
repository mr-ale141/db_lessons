/*
Подзапросы в SQL используются для полусоединений (англ. semijoin), 
выполняемых с помощью операторов EXISTS, а также для анти-соединений 
(англ. antijoin), выполняемых оператором NOT EXISTS.
*/

-- Специальные виды соединений

/*
Для понимания тета-соединений полезно держать в уме основной метод их 
выполнения INNER JOIN в SQL — алгоритм Nested Loop Join:
- Сканировать подходящие под условия выборки строки таблицы A. Для каждой 
такой строки искать сопоставимые строки таблицы B (обычно, но не всегда, 
используется индекс по таблице B)
*/

/*
Полусоединения
Что если нам не нужны ни сопоставимые строки таблицы B, ни атрибуты этих строк, 
а только те строки a∈A, для которых существует хотя бы одна сопоставимая строка b∈B?
Для этого подойдёт операция полусоединения A⋉θB :
- Полусоединение (англ. semijoin) — это бинарная операция A⋉θB над отношениями A и B, 
результатом которой является новое отношение
- В результат полусоединения A⋉θB входят все кортежи a∈A, для которых существует хотя бы 
один кортеж b∈B такой, что a⌒b входит в соединение A⋈θB
- То же самое кратко: A⋉θB = { a ∈ A ∧ ∃ a⌒b ∈ (A ⋈θ B) }
*/

/*
Анти-соединения
Операция анти-соединения (англ. antijoin) является особой разновидностью соединения.
- Анти-соединение (англ. anti-join) — это бинарная операция A▷θB над отношениями A и B, 
результатом которой является новое отношение
- В результат анти-соединения A▷θB входят все кортежи a∈A, для которых не существует 
ни одного кортежа b∈B такого, что a⌒b входит в соединение A⋈θB
- То же самое кратко: A⋉θB = { a ∈ A ∧ ∄ a⌒b ∈ (A ⋈θ B) }
*/

-- Оператор EXISTS
/*
Оператор EXISTS (subquery) принимает аргументом коррелированный подзапрос и возвращает 
только те строки, для которых подзапрос вернул хотя бы один результат
- Данный оператор можно использовать как обычное выражение
- Чаще всего его используют как условие в секции WHERE для реализации полусоединения

Задача: выбрать все билеты, в которых есть хотя бы один перелёт в Чебоксары либо из Чебоксар:

Эту задачу можно было бы решить с помощью соединений INNER JOIN, WHERE и GROUP BY 
(для устранения дубликатов, возникающих для билетов с обратным перелётом):
*/
SELECT
  t.*
FROM tickets t
  INNER JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no
  INNER JOIN flights f ON tf.flight_id = f.flight_id
WHERE (f.arrival_airport = 'CSY' OR f.departure_airport = 'CSY')
GROUP BY t.ticket_no
;
-- С помощью EXISTS можно решить задачу иначе:
SELECT *
FROM tickets t
WHERE EXISTS
  (
    SELECT *
    FROM ticket_flights tf
      INNER JOIN flights f ON tf.flight_id = f.flight_id
    WHERE tf.ticket_no = t.ticket_no
      AND (f.arrival_airport = 'CSY' OR f.departure_airport = 'CSY')
  )
;
/*
Преимущества EXISTS
Выбирая между EXISTS(subquery) и соединением с GROUP BY,
можно указать на следующие преимущества EXISTS:
- Иногда он позволяет избежать роста числа промежуточных результатов вследствие 
декартова произведения при соединении таблиц
- Иногда СУБД формирует более удачный план выполнения для EXISTS(subquery)
- Иногда запрос с EXISTS более понятный и наглядный
*/

-- Оператор NOT EXISTS
/*
Оператор NOT EXISTS (subquery) принимает аргументом коррелированный подзапрос 
и возвращает только те строки, для которых подзапрос не вернул ни одного результата
- Данный оператор можно использовать как обычное выражение
- Чаще всего его используют как условие в секции WHERE для реализации анти-соединения

Пример
В прошлых статьях мы рассматривали задачу:
В каких билетах указано имя пассажира 'MARINA NIKOLAEVA' и при этом в билете нет рейсов через Москву?

Тогда для решения задачи мы использовали:
- Анти-соединения на основе LEFT JOIN b ON ... WHERE b.primary_key IS NULL
- Вложенные соединения — INNER JOIN в скобках

И получили такой SQL-запрос:
*/
SELECT
  t.*
FROM tickets t
  LEFT JOIN (
  ticket_flights tf
    INNER JOIN flights f ON (
    tf.flight_id = f.flight_id
      AND f.arrival_airport IN ('DME', 'SVO', 'VKO')
    )
  )
  ON t.ticket_no = tf.ticket_no
WHERE t.passenger_name = 'MARINA NIKOLAEVA'
  AND f.flight_id IS NULL
;

-- Теперь с помощью NOT EXISTS мы можем решить задачу иначе:
SELECT
  t.*
FROM tickets t
WHERE t.passenger_name = 'MARINA NIKOLAEVA'
  AND NOT EXISTS
  (
    SELECT *
    FROM ticket_flights tf
      INNER JOIN flights f ON tf.flight_id = f.flight_id
    WHERE tf.ticket_no = t.ticket_no
      AND f.arrival_airport IN ('DME', 'SVO', 'VKO')
  )
;

/*
Подытожим
- В полусоединение A⋉θB входят все кортежи a∈A, для которых существует 
хотя бы один кортеж b∈B такой, что a⌒b входит в соединение A⋈θB
- В анти-соединение A▷θB входят все кортежи a∈A, для которых не существует 
ни одного кортежа b∈B такого, что a⌒b входит в соединение A⋈θB
- В SQL полусоединению соответствует оператор EXISTS (subquery), 
а анти-соединению — оператор NOT EXISTS (subquery)
- Реляционные СУБД могут распознавать полусоединения и анти-соединения,
используя для них специализированные версии алгоритма Nested Loop
*/




