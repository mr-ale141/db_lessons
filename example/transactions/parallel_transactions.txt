	Проблемы параллельных транзакций

Напомним, что означает Isolation из набора требований ACID:
	* Изоляция (англ. isolation) — результат параллельного выполнения нескольких 
		транзакций должен быть таким же, как при последовательном выполнении тех же 
		транзакций

Существует ряд теоретических проблем, которые могут возникать при нарушении изоляции 
параллельно выполняемых транзакций. Мы рассмотрим эти проблемы подробно.

Казалось бы, зачем знать о теоретических проблемах?
	* Увы, на и практике изоляция транзакций со стороны СУБД часто бывает неполной
	* Дело в том, что полная изоляция привела бы к неприемлемому падению 
		производительности СУБД в реальных приложениях
	* Поэтому разработчикам реляционных СУБД пришлось пойти на определённые 
		компромиссы и даже позволить программистам самим выбирать уровни изоляции 
		транзакций в своих проектах (это мы обсудим позже)

Другими словами, проблемы изоляции бывают не только в теории, но и на практике.

	Список теоретических проблем

Lost Update (потерянное обновление)
	* Потерянное обновление (англ. lost update) возникает, если две параллельные 
		транзакции меняют данные одной и той же строки и фиксация второй транзакции 
		приводит к потере изменений первой транзакции

Пример Lost Update

Проблема Lost Update возникает, если две транзакции одновременно пытаются списать 
деньги с баланса клиента:
	* Первая транзакция меняет баланс с 1200 на 800 рублей (списывает 400 рублей), 
		и фиксирует это состояние в базе данных
	* Вторая транзакция меняет баланс с 1200 на 900 рублей (списывает 300 рублей), 
		и фиксирует это состояние в базе данных

Lost Update и объектно-ориентированный стиль

Напомним, что в объектно-ориентированной программе изменения в моделях определяют 
изменения данных в базе данных, а не наоборот
	* Это увеличивает вероятность проявления Lost Update в определённых условиях
	* Значит, разработчикам высоконагруженных систем надо уметь решать такие 
		проблемы

Попытка минимизировать количество запросов не решает проблему Lost Update в общем 
случае, так что не получится решить эту проблему путём написания менее 
сопровождаемого кода с переносом бизнес-логики в SQL-запросы.

	Phantom Read 

Фантомное чтение (англ. phantom read) возникает, когда два последовательных 
выполнения одного и того же SELECT-запроса в одной и той же транзакции дают разный 
набор строк.

Другими словами, ранее выбранная строка таблицы исчезает, как фантом.

Пример Phantom Read

Две транзакции одновременно пытаются выполнить следующие действия с аккаунтом с 
номером +78362685453:
	* Первая транзакция выполняет запрос SELECT * FROM account WHERE phone = 
		'+78362685453'
		- В результате получает аккаунт с балансом 1200 рублей
	* Вторая транзакция удаляет аккаунт запросом DELETE * FROM account WHERE 
		phone = '+78362685453' и затем фиксируется запросом COMMIT
		- В результате строка исчезает из таблицы
	* Первая транзакция снова выполняет запрос SELECT * FROM account WHERE 
		phone = '+78362685453'
		- Но такой строки уже нет в таблице!

Результат: скрипт, управляющий первой транзакцией, потерял аккаунт, который ранее 
был найден, что может привести к ошибкам выполнения программы.

	Non-Repeatable Read

Неповторяющееся чтение (англ. non-repeatable read) возникает, когда два 
последовательных выполнения одного и того же SELECT-запроса в одной и той же 
транзакции дают разные значения для одной и той же строки.

Разница между фантомным чтением и неповторяющемся чтением такова:
	* Если два одинаковых SELECT-запроса вернули разный набор строк, то это 
		фантомное чтение
		- Другими словами, транзакция наблюдает результат вставок (INSERT) и 
			удалений (DELETE) других транзакций
	* Если два одинаковых SELECT-запроса вернули разные значения в одной и той же 
		строке, то это неповторяющееся чтение
		- Другими словами, транзакция наблюдает результат обновлений (UPDATE) 
			других транзакций

Подробнее о разнице между Phantom Read и Non-Repeatable Read: Non-Repeatable Read 
vs Phantom Read? - Stack Overflow 
(https://stackoverflow.com/questions/11043712/non-repeatable-read-vs-phantom-read)

Пример Non-Repeatable Read

Две транзакции одновременно пытаются выполнить следующие действия с аккаунтом с 
номером +78362685453, на балансе которого было 1200 рублей:
	* Первая транзакция выполняет запрос SELECT * FROM account WHERE 
		phone = '+78362685453'
		- В результате получает аккаунт с балансом 1200 рублей
	* Вторая транзакция обновляет баланс запросом UPDATE account SET 
		balance = 900 WHERE phone = '+78362685453' и затем фиксируется 
		запросом COMMIT
		- В результате баланс меняется на 900 рублей
	* Первая транзакция снова выполняет запрос SELECT * FROM account WHERE 
		phone = '+78362685453'
Результат: скрипт, управляющий первой транзакцией, видит противоречивые значения 
баланса, что может привести к ошибкам выполнения программы.

Может показаться, что non-repeatable read — это изящное решение проблемы Lost 
Update. На самом деле нет: проблема Lost Update легко возникает и как без 
повторяющихся SELECT-запросов, так и с повторяющимися.

	Dirty Read

Грязное чтение (англ. dirty read) возникает, когда SELECT-запрос в одной транзакции 
видит результаты незафиксированных изменений другой транзакции

Отметим, что:
	* Проблемы Phantom Read и Non-Repeatable касаются взаимодействия транзакции с 
		другими транзакциями, которые успели зафиксироваться
	* Проблема Dirty Read, напротив, касется взаимодействия транзакции с другими 
		незафиксированными транзакциями

Подробнее о разнице между Non-Repeatable Read и Dirty Read: Dirty read vs 
Non-repeatable read - Stack Overflow
(https://stackoverflow.com/questions/18297626/dirty-read-vs-non-repeatable-read)

Пример Dirty Read

Две транзакции одновременно пытаются выполнить следующие действия с аккаунтом с 
номером +78362685453, на балансе которого было ноль рублей:
	* Первая транзакция пополняет счёт на 400 рублей, обновляя баланс запросом 
		UPDATE account SET balance = 400 WHERE phone = '+78362685453' и не 
		фиксируется
		- Баланс стал положительным, но транзакция ещё не зафиксирована
	* Вторая транзакция выполняет запрос SELECT * FROM account WHERE 
		phone = '+78362685453'
		- В результате получает аккаунт с балансом 400 рублей
	* Вторая транзакция списывает 300 рублей, обновляя баланс запросом 
		UPDATE account SET balance = 100 WHERE phone = '+78362685453' 
		и затем фиксируется запросом COMMIT
		- В результате баланс меняется на 100 рублей
	* Первая транзакция откатывается с помощью ROLLBACK
Результат: приложение думает, что операция пополнения счёта провалилась, но на 
самом деле вторая транзакция списала деньги с пополненного счёта и ещё оставила 
100 рублей!

	Write Skew

Перекос записи (англ. write skew) возникает, когда два параллельно выполняемых 
экземпляра приложения в паралельных транзакциях принимают решение, которого они 
никогда бы не приняли при последовательном выполнении, и приводят данные в 
недопустимое состояние

Подробнее об отличии Write Skew от других проблем: Why write skew can happen in 
Repeatable reads? - Stack Overflow
(https://stackoverflow.com/questions/48417632/why-write-skew-can-happen-in-repeatable-reads)

Первый пример Write Skew

Для демонстрации Write Skew нам потребуется иной пример.
	* Допустим, в некоторой системе есть онлайн-курсы, и учащийся может записаться 
		в очередной поток выбранного курса
	* При этом потоки имеют ограниченную ёмкость (англ. capacity) — например, в 
		каждый поток набирают не более 30 человек
(рис. write_skew_example.png)

Представим себе ситуацию, когда два человека одновременно решили записаться на 
поток, где уже набрано 29 человек из 30:
	* Первый PHP-скрипт открывает транзакцию, считает число участников и получает 29
	* Второй PHP-скрипт открывает транзакцию, считает число участников и получает 29
	* Первый PHP-скрипт в транзакции записывает учащегося на поток, вставляя запись 
		в таблицу course_group_participant
	* Второй PHP-скрипт в транзакции записывает учащегося на поток, вставляя запись 
		в таблицу course_group_participant
	* Обе транзакции фиксируются
Результат: на потоке 31 участник при ёмкости 30 человек.

Второй пример Write Skew

Проблема будет иметь более существенные последствия, если вместо потоков и курсов 
взять другой пример:
	* Врачи записываются на дежурство в городской больнице, при этом в любой день 
		должен дежурить минимум один врач
	* Два врача одновременно отменяют своё дежурство в параллельно выполняемых 
		транзакциях
Результат: дежурных становится ноль.

	Как предотвратить проблемы

СУБД для изоляции транзакций делает следующее:
	* Предоставляет несколько уровней изоляции транзакций, которые мы обсудим позже
	* Устанавливает один из уровней изоляции по умолчанию и позволяет менять его 
		каждому соединению (т.е. отдельно для каждой сессии)
	* Предоставляет дополнительные механизмы изоляции транзакций, такие как 
		SELECT FOR UPDATE или именованные блокировки

Всё остальное, что требуется для правильной изоляции бизнес-транзакций, должен 
сделать сам программист.

	Подытожим

Изоляция (англ. isolation) — результат параллельного выполнения нескольких 
транзакций должен быть таким же, как при последовательном выполнении тех же 
транзакций

Существует ряд теоретических проблем, которые могут возникать при нарушении изоляции 
параллельно выполняемых транзакций
	* Потерянное обновление (англ. lost update) возникает, если две параллельные 
		транзакции меняют данные одной и той же строки и фиксация второй транзакции 
		приводит к потере изменений первой транзакции
	* Фантомное чтение (англ. phantom read) возникает, когда два последовательных 
		выполнения одного и того же SELECT-запроса в одной и той же транзакции дают 
		разный набор строк
	* Неповторяющееся чтение (англ. non-repeatable read) возникает, когда два 
		последовательных выполнения одного и того же SELECT-запроса в одной и той же 
		транзакции дают разные значения для одной и той же строки
	* Грязное чтение (англ. dirty read) возникает, когда SELECT-запрос в одной 
		транзакции видит результаты незафиксированных изменений другой транзакции
	* Перекос записи (англ. write skew) возникает, когда два параллельно выполняемых 
		экземпляра приложения в паралельных транзакциях принимают решение, которого 
		они никогда бы не приняли при последовательном выполнении, и приводят данные 
		в недопустимое состояние

СУБД предоставляет все инструменты, необходимые для решения указанных проблем. 
Правильное использование этих инструментов — задача программиста.
