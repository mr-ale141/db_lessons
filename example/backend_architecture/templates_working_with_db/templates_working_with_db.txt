	Шаблоны работы с базой данных

В этой статье мы рассмотрим основные шаблоны для взаимодействия модели и базы данных в веб-приложениях.

Ряд шаблонов, о которых идёт речь в этой статье, подробно описаны в книге “Patterns of Enterprise Application 
Architecture” Мартина Фаулера, а также в его блоге.

А прежде напомним два связанных шаблона проектирования в системе шаблонов GRASP:
	Информационный эксперт (Infromation Expert) — это класс, который хранит и данные, и методы для их обработки
	Чистая выдумка (Pure Fabrication) — класс, который не имеет аналогов в предметной области и обычно хранит 
		только методы обработки данных, но не сами данные
		
Среди перечисленных ниже шаблонов проектирования только Active Record является информационным экспертом с точки 
зрения GRASP, а остальные шаблоны являются чистой выдумкой (pure fabrication).

Другими словами, только шаблон Active Record хранит и данные предметной области, и методы для взаимодействия с 
базой данных (что, впрочем, не делает его краше).

	Active Record

При использовании шаблона Active Record объект класса модели соответствует строке в таблице, а взаимодействие 
с базой данных размещается прямо в классе модели.

Пример (см. TPL_db_1.png):
	* Есть базе данных таблица article, которая хранит данные статей
	* В приложении есть класс Article — каждый объект этого типа соответствует одной строке таблицы article

В рамках шаблона Active Record модель дополняется методами для прямой работы с соответствующей строкой таблицы:
	* Чтение данных могут выполнять статические методы с глаголом find, например findById(int $id), 
		findAllTitle(string $title)
	* Обновление данных выполняет метод save()
		- При вызове этого метода класс модели сохраняет свои данные в строку таблицы в базе данных
		- Обычно выбор между INSERT и UPDATE происходит внутри метода save() — например, по условию 
			$this->id === null
	* Удаление данных выполняет метод delete()
		- При вызове этого метода класс модели удаляет соответствующую объекту строку из таблицы в базе данных
		- После вызова метода delete() объект больше нельзя использовать, т.к. из базы данных он уже удалён

	Недостатки Active Record

Шаблон ActiveRecord часто становится проблемой для долгосрочных проектов, вызывая смешение архитектурных слоёв 
и рост количества запутанного кода (спагетти-кода).

	Нарушение архитектурных слоёв

Напомним, что в концепции архитектурных слоёв выделяют 4 основных слоя (см. ../MVC/MVC_4.png)

Шаблон Active Record смешивает между собой два слоя:
	* Слой логики предметной области (Domain Layer)
	* Слой доступа к данным (Persistence Layer)

	Появление спагетти-кода

Для проектов, развивающихся в течение долгого времени, шаблон Active Record становится вызывает рост 
количества запутанного кода (спагетти-кода):
	* В коде класса присутствует одновременно и бизнес-логика, и детали взаимодействия с базой данных
	* При наличии нескольких взаимосвязанных сущностей код обычно добавляется в произвольно выбранную сущность
		- Например, есть классы Client (соответствует таблице client) и ClientEmail (соответствует 
			таблице email). Куда добавить функцию для выбора клиента по email-адресу? Для добавления 
			email-адреса клиенту?
	* Часто возникает многократное сохранение объекта Active Record в течение одной и той же операции
	* Часто возникают странные решения, когда нужно выполнять некоторые дополнительные действия до или 
		после сохранения объекта в базу данных 

	Table Data Gateway
	
Смешение бизнес-логики и доступа к данным вызывает ряд проблем.

Решить их позволяет шаблон Table Data Gateway, в рамках которого реализация взаимодействия с таблицей 
переходит в отдельный класс
	* Такой класс часто называют с суффиксом Table, например, ArticleTable
	* Этот класс выступает в роли шлюза (англ. Gateway) для доступа к данным

(см. Пример TPL_db_2.png)

Важные аспекты данного шаблона:
	* Модель по-прежнему соответствует одной строке таблицы, но уже не управляет ею
	* На одну таблицу в базе данных создаётся один Table Data Gateway
	* Названия методов в Table Data Gateway обычно используют глаголы языка SQL — insert, update и delete
		- Исключение часто делают для глагола select, заменяя его на find или fetch

	Преимущества Table Data Gateway перед Active Record

Table Gateway поддерживает разделение на архитектурные слои:
	* Модель принадлежит слою предметной области (Domain Layer)
	* Table Data Gateway принадлежит слою доступа к данным (Persistence Layer)

	Недостаки Table Data Gateway

* Модели слоя предметной области обычно сами обращаются к Table Data Gateway, что немного загрязняет их 
	терминологией и техническими деталями слоя доступа к данным
* На одну таблицу по-прежнему создаётся один Table Data Gateway, что может приводить к сложностям в случае, 
	если SQL-запрос должен обращаться одновременно к нескольким таблицам из-за соединений или подзапросов

	Data Access Object

Шаблон DAO (Data Access Object) описан в документации языка Java.

DAO пригождается в ситуации, когда приложению нужно читать данные одновременно из нескольких таблиц
	* Например, для страницы со списком статей нужна возможность фильтрации статей по тегам, 
		которыми отмечена статья
	* Для этого потребуется обращаться к дополнительным таблицам: tag и article_tag
	
Шаблон DAO вводит класс, задача которого — читать данные из источника (см. TPL_db_3.png)
Здесь класс ArticleQuerySource представляет шаблон DAO.

	Отличия DAO от Table Data Gateway

* DAO предназначен для инкапсуляции чтения данных из произвольного источника — включая реляционные базы данных
* DAO может читать данные из нескольких таблиц
* DAO — в оригинальном изложении — не занимается записью данных, т.е. не выполняет запросов INSERT / UPDATE / DELETE

	Шаблон Repository
	
Шаблон Repository использует метафору коллекции объектов (см. TPL_db_4.png)
	* Объект репозитория представляет собой коллекцию объектов, обладающую свойством персистентности 
		(т.е. сохранения данных во внешнее хранилище)
	* Будучи коллекцией, репозиторий не использует терминов языка SQL, таких как глаголы 
		select, insert, update, delete
	* Вместо терминов SQL используются термины, подходящие для абстрактного типа данных «коллекция объектов»

	Метафора коллекции

Использование метафоры коллекции вместо метафоры базы данных — ключевой аспект шаблона Repository

Репозиторий использует следующие глаголы:
	* find для получения объектов по заданным критериям
		- этот метод инкапсулирует запросы SELECT
	* add для добавления объекта, который ранее не был в коллекции
		- этот метод обычно инкапсулирует запрос INSERT
	* store на случай, если нужно сохранить объект независимо от того, добавлялся ли он ранее
	* remove для удаления объекта из коллекции
		- этот метод обычно инкапсулирует запрос DELETE
		- при этом метод часто принимает не удаляемый объект модели, а только ключ (идентификатор) 
			удаляемого объекта

	Отличия от Table Data Gateway

	Разные метафоры

Первое очевидное различие в метафоре:
	* Table Data Gateway инкапсулирует работу с таблицей, но использует при этом 
		глаголы SQL: insert, update, delete
	* Repository использует метафору коллекции и соответствующие глаголы

	Инкапсуляция работы с группой таблиц

Менее очевидное отличие в том, что Repository не обязан использовать только одну таблицу.

(см. TPL_db_5.png)

Здесь ArticleRepository при сохранении статьи может обращаться сразу к трём таблицам: article, tag и article_tag
	* Данная особенность позволяет репозиториям изящно работать с агрегатами
		- с точки зрения приложения добавление в коллекцию целого агрегата (такого как Order с несколькими 
			OrderItem) ничем не отличается от добавления простой сущности (такой как User)
	* Эта особенность также сближает шаблон Repository с шаблоном DAO (Data Access Object)
		- при этом DAO используется для чтения данных без цели редактирования этих данных
		- Repository, напротив, может получать данные из БД с целью дальнейшего их изменения или удаления

Репозиторий обязан соблюдать границы: 
	* репозиторий агрегата не должен обращаться к таблицам, принадлежащим другим 
		агрегатам или независимым сущностям!
